// Ovie Standard Library - Time Module
// Time and duration handling with deterministic behavior
// All operations are designed to be reproducible and offline-first

use core::{Result, Option, ok, err, some, none};

// ===== TIME TYPES =====

// Instant represents a point in time (monotonic clock)
struct Instant {
    nanoseconds: Number, // Nanoseconds since system boot
}

// SystemTime represents a point in time (system clock)
struct SystemTime {
    unix_timestamp: Number, // Seconds since Unix epoch
    nanoseconds: Number,    // Additional nanoseconds
}

// Duration represents a span of time
struct Duration {
    seconds: Number,
    nanoseconds: Number, // 0-999,999,999
}

// Date represents a calendar date
struct Date {
    year: Number,
    month: Number,  // 1-12
    day: Number,    // 1-31
}

// Time represents a time of day
struct Time {
    hour: Number,   // 0-23
    minute: Number, // 0-59
    second: Number, // 0-59
    nanosecond: Number, // 0-999,999,999
}

// DateTime combines date and time
struct DateTime {
    date: Date,
    time: Time,
    timezone_offset: Number, // Offset from UTC in seconds
}

// Weekday enumeration
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday,
}

// Month enumeration
enum Month {
    January,
    February,
    March,
    April,
    May,
    June,
    July,
    August,
    September,
    October,
    November,
    December,
}

// ===== DURATION OPERATIONS =====

impl Duration {
    // Create a new duration from seconds
    fn from_seconds(seconds: Number) -> Duration {
        mut whole_seconds = truncate(seconds);
        mut fractional = seconds - whole_seconds;
        mut nanos = fractional * 1_000_000_000;
        
        return Duration {
            seconds: whole_seconds,
            nanoseconds: nanos,
        };
    }
    
    // Create a new duration from milliseconds
    fn from_millis(millis: Number) -> Duration {
        return Duration.from_seconds(millis / 1000.0);
    }
    
    // Create a new duration from microseconds
    fn from_micros(micros: Number) -> Duration {
        return Duration.from_seconds(micros / 1_000_000.0);
    }
    
    // Create a new duration from nanoseconds
    fn from_nanos(nanos: Number) -> Duration {
        mut seconds = truncate(nanos / 1_000_000_000);
        mut remaining_nanos = nanos % 1_000_000_000;
        
        return Duration {
            seconds: seconds,
            nanoseconds: remaining_nanos,
        };
    }
    
    // Get total seconds as floating point
    fn as_seconds(self) -> Number {
        return self.seconds + (self.nanoseconds / 1_000_000_000.0);
    }
    
    // Get total milliseconds
    fn as_millis(self) -> Number {
        return (self.seconds * 1000) + (self.nanoseconds / 1_000_000);
    }
    
    // Get total microseconds
    fn as_micros(self) -> Number {
        return (self.seconds * 1_000_000) + (self.nanoseconds / 1000);
    }
    
    // Get total nanoseconds
    fn as_nanos(self) -> Number {
        return (self.seconds * 1_000_000_000) + self.nanoseconds;
    }
    
    // Add two durations
    fn add(self, other: Duration) -> Duration {
        mut total_nanos = self.nanoseconds + other.nanoseconds;
        mut carry_seconds = 0;
        
        if total_nanos >= 1_000_000_000 {
            carry_seconds = truncate(total_nanos / 1_000_000_000);
            total_nanos = total_nanos % 1_000_000_000;
        }
        
        return Duration {
            seconds: self.seconds + other.seconds + carry_seconds,
            nanoseconds: total_nanos,
        };
    }
    
    // Subtract two durations
    fn subtract(self, other: Duration) -> Result<Duration, String> {
        if self.as_nanos() < other.as_nanos() {
            return err("Cannot subtract larger duration from smaller duration");
        }
        
        mut self_total_nanos = self.as_nanos();
        mut other_total_nanos = other.as_nanos();
        mut result_nanos = self_total_nanos - other_total_nanos;
        
        return ok(Duration.from_nanos(result_nanos));
    }
    
    // Multiply duration by a scalar
    fn multiply(self, factor: Number) -> Duration {
        mut total_nanos = self.as_nanos() * factor;
        return Duration.from_nanos(total_nanos);
    }
    
    // Divide duration by a scalar
    fn divide(self, divisor: Number) -> Result<Duration, String> {
        if divisor == 0 {
            return err("Cannot divide duration by zero");
        }
        
        mut total_nanos = self.as_nanos() / divisor;
        return ok(Duration.from_nanos(total_nanos));
    }
    
    // Check if duration is zero
    fn is_zero(self) -> Boolean {
        return self.seconds == 0 && self.nanoseconds == 0;
    }
    
    // Compare durations
    fn compare(self, other: Duration) -> Number {
        mut self_nanos = self.as_nanos();
        mut other_nanos = other.as_nanos();
        
        if self_nanos < other_nanos {
            return -1;
        } else if self_nanos > other_nanos {
            return 1;
        } else {
            return 0;
        }
    }
}

// ===== INSTANT OPERATIONS =====

impl Instant {
    // Get current instant (monotonic time)
    fn now() -> Instant {
        return Instant {
            nanoseconds: get_monotonic_time_nanos(),
        };
    }
    
    // Calculate duration since another instant
    fn duration_since(self, earlier: Instant) -> Result<Duration, String> {
        if self.nanoseconds < earlier.nanoseconds {
            return err("Earlier instant is actually later");
        }
        
        mut elapsed_nanos = self.nanoseconds - earlier.nanoseconds;
        return ok(Duration.from_nanos(elapsed_nanos));
    }
    
    // Calculate duration until another instant
    fn duration_until(self, later: Instant) -> Result<Duration, String> {
        return later.duration_since(self);
    }
    
    // Add duration to instant
    fn add_duration(self, duration: Duration) -> Instant {
        return Instant {
            nanoseconds: self.nanoseconds + duration.as_nanos(),
        };
    }
    
    // Subtract duration from instant
    fn subtract_duration(self, duration: Duration) -> Result<Instant, String> {
        if duration.as_nanos() > self.nanoseconds {
            return err("Cannot subtract duration larger than instant");
        }
        
        return ok(Instant {
            nanoseconds: self.nanoseconds - duration.as_nanos(),
        });
    }
}

// ===== SYSTEM TIME OPERATIONS =====

impl SystemTime {
    // Get current system time
    fn now() -> SystemTime {
        mut current_time = get_system_time();
        return SystemTime {
            unix_timestamp: current_time.seconds,
            nanoseconds: current_time.nanoseconds,
        };
    }
    
    // Create system time from Unix timestamp
    fn from_unix_timestamp(timestamp: Number) -> SystemTime {
        mut whole_seconds = truncate(timestamp);
        mut fractional = timestamp - whole_seconds;
        mut nanos = fractional * 1_000_000_000;
        
        return SystemTime {
            unix_timestamp: whole_seconds,
            nanoseconds: nanos,
        };
    }
    
    // Get Unix timestamp as floating point
    fn as_unix_timestamp(self) -> Number {
        return self.unix_timestamp + (self.nanoseconds / 1_000_000_000.0);
    }
    
    // Calculate duration since another system time
    fn duration_since(self, earlier: SystemTime) -> Result<Duration, String> {
        mut self_timestamp = self.as_unix_timestamp();
        mut earlier_timestamp = earlier.as_unix_timestamp();
        
        if self_timestamp < earlier_timestamp {
            return err("Earlier time is actually later");
        }
        
        mut elapsed_seconds = self_timestamp - earlier_timestamp;
        return ok(Duration.from_seconds(elapsed_seconds));
    }
    
    // Add duration to system time
    fn add_duration(self, duration: Duration) -> SystemTime {
        mut new_timestamp = self.as_unix_timestamp() + duration.as_seconds();
        return SystemTime.from_unix_timestamp(new_timestamp);
    }
    
    // Subtract duration from system time
    fn subtract_duration(self, duration: Duration) -> SystemTime {
        mut new_timestamp = self.as_unix_timestamp() - duration.as_seconds();
        return SystemTime.from_unix_timestamp(new_timestamp);
    }
    
    // Convert to DateTime in UTC
    fn to_datetime_utc(self) -> DateTime {
        return unix_timestamp_to_datetime(self.as_unix_timestamp(), 0);
    }
    
    // Convert to DateTime in local timezone
    fn to_datetime_local(self) -> DateTime {
        mut local_offset = get_local_timezone_offset();
        return unix_timestamp_to_datetime(self.as_unix_timestamp(), local_offset);
    }
}

// ===== DATE OPERATIONS =====

impl Date {
    // Create a new date
    fn new(year: Number, month: Number, day: Number) -> Result<Date, String> {
        if !is_valid_date(year, month, day) {
            return err("Invalid date");
        }
        
        return ok(Date {
            year: year,
            month: month,
            day: day,
        });
    }
    
    // Get current date in UTC
    fn today_utc() -> Date {
        mut now = SystemTime.now();
        mut datetime = now.to_datetime_utc();
        return datetime.date;
    }
    
    // Get current date in local timezone
    fn today_local() -> Date {
        mut now = SystemTime.now();
        mut datetime = now.to_datetime_local();
        return datetime.date;
    }
    
    // Get day of week
    fn weekday(self) -> Weekday {
        // Zeller's congruence algorithm
        mut year = self.year;
        mut month = self.month;
        mut day = self.day;
        
        if month < 3 {
            month = month + 12;
            year = year - 1;
        }
        
        mut century = truncate(year / 100);
        mut year_of_century = year % 100;
        
        mut day_of_week = (day + truncate((13 * (month + 1)) / 5) + year_of_century + 
                          truncate(year_of_century / 4) + truncate(century / 4) - 2 * century) % 7;
        
        // Convert to Monday = 0 format
        day_of_week = (day_of_week + 5) % 7;
        
        if day_of_week == 0 { return Weekday.Monday; }
        else if day_of_week == 1 { return Weekday.Tuesday; }
        else if day_of_week == 2 { return Weekday.Wednesday; }
        else if day_of_week == 3 { return Weekday.Thursday; }
        else if day_of_week == 4 { return Weekday.Friday; }
        else if day_of_week == 5 { return Weekday.Saturday; }
        else { return Weekday.Sunday; }
    }
    
    // Check if year is leap year
    fn is_leap_year(year: Number) -> Boolean {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }
    
    // Get number of days in month
    fn days_in_month(self) -> Number {
        if self.month == 2 {
            return if Date.is_leap_year(self.year) { 29 } else { 28 };
        } else if self.month == 4 || self.month == 6 || self.month == 9 || self.month == 11 {
            return 30;
        } else {
            return 31;
        }
    }
    
    // Add days to date
    fn add_days(self, days: Number) -> Date {
        mut current_date = self;
        mut remaining_days = days;
        
        while remaining_days > 0 {
            mut days_in_current_month = current_date.days_in_month();
            mut days_left_in_month = days_in_current_month - current_date.day;
            
            if remaining_days <= days_left_in_month {
                current_date.day = current_date.day + remaining_days;
                break;
            } else {
                remaining_days = remaining_days - days_left_in_month - 1;
                current_date.day = 1;
                current_date.month = current_date.month + 1;
                
                if current_date.month > 12 {
                    current_date.month = 1;
                    current_date.year = current_date.year + 1;
                }
            }
        }
        
        return current_date;
    }
    
    // Subtract days from date
    fn subtract_days(self, days: Number) -> Date {
        mut current_date = self;
        mut remaining_days = days;
        
        while remaining_days > 0 {
            if remaining_days < current_date.day {
                current_date.day = current_date.day - remaining_days;
                break;
            } else {
                remaining_days = remaining_days - current_date.day;
                current_date.month = current_date.month - 1;
                
                if current_date.month < 1 {
                    current_date.month = 12;
                    current_date.year = current_date.year - 1;
                }
                
                current_date.day = current_date.days_in_month();
            }
        }
        
        return current_date;
    }
    
    // Format date as string
    fn format(self, format_string: String) -> String {
        mut result = format_string;
        
        // Replace format specifiers
        result = replace_all(result, "YYYY", pad_number(self.year, 4));
        result = replace_all(result, "MM", pad_number(self.month, 2));
        result = replace_all(result, "DD", pad_number(self.day, 2));
        
        return result;
    }
}

// ===== TIME OPERATIONS =====

impl Time {
    // Create a new time
    fn new(hour: Number, minute: Number, second: Number, nanosecond: Number) -> Result<Time, String> {
        if hour < 0 || hour > 23 {
            return err("Hour must be 0-23");
        }
        if minute < 0 || minute > 59 {
            return err("Minute must be 0-59");
        }
        if second < 0 || second > 59 {
            return err("Second must be 0-59");
        }
        if nanosecond < 0 || nanosecond >= 1_000_000_000 {
            return err("Nanosecond must be 0-999,999,999");
        }
        
        return ok(Time {
            hour: hour,
            minute: minute,
            second: second,
            nanosecond: nanosecond,
        });
    }
    
    // Get current time in UTC
    fn now_utc() -> Time {
        mut now = SystemTime.now();
        mut datetime = now.to_datetime_utc();
        return datetime.time;
    }
    
    // Get current time in local timezone
    fn now_local() -> Time {
        mut now = SystemTime.now();
        mut datetime = now.to_datetime_local();
        return datetime.time;
    }
    
    // Convert to total seconds since midnight
    fn as_seconds_since_midnight(self) -> Number {
        return (self.hour * 3600) + (self.minute * 60) + self.second + (self.nanosecond / 1_000_000_000.0);
    }
    
    // Create time from seconds since midnight
    fn from_seconds_since_midnight(seconds: Number) -> Result<Time, String> {
        if seconds < 0 || seconds >= 86400 {
            return err("Seconds must be 0-86399");
        }
        
        mut hour = truncate(seconds / 3600);
        mut remaining = seconds % 3600;
        mut minute = truncate(remaining / 60);
        mut second_part = remaining % 60;
        mut second = truncate(second_part);
        mut nanosecond = (second_part - second) * 1_000_000_000;
        
        return Time.new(hour, minute, second, nanosecond);
    }
    
    // Add duration to time
    fn add_duration(self, duration: Duration) -> Time {
        mut total_seconds = self.as_seconds_since_midnight() + duration.as_seconds();
        total_seconds = total_seconds % 86400; // Wrap around at midnight
        
        return Time.from_seconds_since_midnight(total_seconds).unwrap();
    }
    
    // Subtract duration from time
    fn subtract_duration(self, duration: Duration) -> Time {
        mut total_seconds = self.as_seconds_since_midnight() - duration.as_seconds();
        
        if total_seconds < 0 {
            total_seconds = total_seconds + 86400; // Wrap around to previous day
        }
        
        return Time.from_seconds_since_midnight(total_seconds).unwrap();
    }
    
    // Format time as string
    fn format(self, format_string: String) -> String {
        mut result = format_string;
        
        // Replace format specifiers
        result = replace_all(result, "HH", pad_number(self.hour, 2));
        result = replace_all(result, "mm", pad_number(self.minute, 2));
        result = replace_all(result, "ss", pad_number(self.second, 2));
        
        return result;
    }
}

// ===== DATETIME OPERATIONS =====

impl DateTime {
    // Create a new datetime
    fn new(date: Date, time: Time, timezone_offset: Number) -> DateTime {
        return DateTime {
            date: date,
            time: time,
            timezone_offset: timezone_offset,
        };
    }
    
    // Get current datetime in UTC
    fn now_utc() -> DateTime {
        mut now = SystemTime.now();
        return now.to_datetime_utc();
    }
    
    // Get current datetime in local timezone
    fn now_local() -> DateTime {
        mut now = SystemTime.now();
        return now.to_datetime_local();
    }
    
    // Convert to system time
    fn to_system_time(self) -> SystemTime {
        mut unix_timestamp = date_time_to_unix_timestamp(self.date, self.time, self.timezone_offset);
        return SystemTime.from_unix_timestamp(unix_timestamp);
    }
    
    // Convert to UTC
    fn to_utc(self) -> DateTime {
        mut system_time = self.to_system_time();
        return system_time.to_datetime_utc();
    }
    
    // Convert to different timezone
    fn to_timezone(self, new_offset: Number) -> DateTime {
        mut utc_datetime = self.to_utc();
        mut system_time = utc_datetime.to_system_time();
        return unix_timestamp_to_datetime(system_time.as_unix_timestamp(), new_offset);
    }
    
    // Add duration to datetime
    fn add_duration(self, duration: Duration) -> DateTime {
        mut system_time = self.to_system_time();
        mut new_system_time = system_time.add_duration(duration);
        return unix_timestamp_to_datetime(new_system_time.as_unix_timestamp(), self.timezone_offset);
    }
    
    // Subtract duration from datetime
    fn subtract_duration(self, duration: Duration) -> DateTime {
        mut system_time = self.to_system_time();
        mut new_system_time = system_time.subtract_duration(duration);
        return unix_timestamp_to_datetime(new_system_time.as_unix_timestamp(), self.timezone_offset);
    }
    
    // Format datetime as string
    fn format(self, format_string: String) -> String {
        mut result = format_string;
        
        // Date formatting
        result = self.date.format(result);
        
        // Time formatting
        result = self.time.format(result);
        
        // Timezone formatting
        if contains(result, "Z") {
            if self.timezone_offset == 0 {
                result = replace_all(result, "Z", "Z");
            } else {
                mut offset_hours = truncate(abs(self.timezone_offset) / 3600);
                mut offset_minutes = truncate((abs(self.timezone_offset) % 3600) / 60);
                mut sign = if self.timezone_offset >= 0 { "+" } else { "-" };
                mut offset_str = sign + pad_number(offset_hours, 2) + ":" + pad_number(offset_minutes, 2);
                result = replace_all(result, "Z", offset_str);
            }
        }
        
        return result;
    }
}

// ===== UTILITY FUNCTIONS =====

// Sleep for a duration (blocks execution)
fn sleep(duration: Duration) {
    sleep_nanos(duration.as_nanos());
}

// Sleep for milliseconds
fn sleep_millis(millis: Number) {
    sleep(Duration.from_millis(millis));
}

// Sleep for seconds
fn sleep_seconds(seconds: Number) {
    sleep(Duration.from_seconds(seconds));
}

// Measure execution time of a function
fn measure_time<T>(func: fn() -> T) -> (T, Duration) {
    mut start = Instant.now();
    mut result = func();
    mut end = Instant.now();
    mut elapsed = end.duration_since(start).unwrap();
    
    return (result, elapsed);
}

// ===== HELPER FUNCTIONS =====

// Check if date is valid
fn is_valid_date(year: Number, month: Number, day: Number) -> Boolean {
    if month < 1 || month > 12 {
        return false;
    }
    
    if day < 1 {
        return false;
    }
    
    mut temp_date = Date { year: year, month: month, day: 1 };
    mut max_days = temp_date.days_in_month();
    
    return day <= max_days;
}

// Convert Unix timestamp to DateTime
fn unix_timestamp_to_datetime(timestamp: Number, timezone_offset: Number) -> DateTime {
    // Adjust for timezone
    mut adjusted_timestamp = timestamp + timezone_offset;
    
    // Calculate date
    mut days_since_epoch = truncate(adjusted_timestamp / 86400);
    mut seconds_in_day = adjusted_timestamp % 86400;
    
    // Unix epoch is January 1, 1970 (Thursday)
    mut epoch_date = Date { year: 1970, month: 1, day: 1 };
    mut date = epoch_date.add_days(days_since_epoch);
    
    // Calculate time
    mut time = Time.from_seconds_since_midnight(seconds_in_day).unwrap();
    
    return DateTime {
        date: date,
        time: time,
        timezone_offset: timezone_offset,
    };
}

// Convert DateTime to Unix timestamp
fn date_time_to_unix_timestamp(date: Date, time: Time, timezone_offset: Number) -> Number {
    // Calculate days since Unix epoch
    mut epoch_date = Date { year: 1970, month: 1, day: 1 };
    mut days_since_epoch = calculate_days_between(epoch_date, date);
    
    // Calculate total seconds
    mut total_seconds = (days_since_epoch * 86400) + time.as_seconds_since_midnight();
    
    // Adjust for timezone
    return total_seconds - timezone_offset;
}

// Calculate days between two dates
fn calculate_days_between(start_date: Date, end_date: Date) -> Number {
    // Simple implementation - could be optimized
    mut current = start_date;
    mut days = 0;
    
    while current.year < end_date.year || 
          (current.year == end_date.year && current.month < end_date.month) ||
          (current.year == end_date.year && current.month == end_date.month && current.day < end_date.day) {
        current = current.add_days(1);
        days = days + 1;
    }
    
    return days;
}

// Pad number with leading zeros
fn pad_number(num: Number, width: Number) -> String {
    mut str_num = number_to_string(num);
    
    while length(str_num) < width {
        str_num = "0" + str_num;
    }
    
    return str_num;
}

// ===== BUILT-IN FUNCTION DECLARATIONS =====
// These functions are implemented by the runtime

fn get_monotonic_time_nanos() -> Number;
fn get_system_time() -> SystemTime;
fn get_local_timezone_offset() -> Number;
fn sleep_nanos(nanos: Number);
fn truncate(x: Number) -> Number;
fn abs(x: Number) -> Number;
fn replace_all(text: String, from: String, to: String) -> String;
fn number_to_string(num: Number) -> String;
fn length(text: String) -> Number;
fn contains(text: String, pattern: String) -> Boolean;